---
title: "GEO UNIV'R Tunisie 2024"
subtitle: "LUN3 - Acquisition de donn√©es g√©ographiques et visualisations de base"
lang: fr
date: "2024-05-13"
date-format: iso
author: "Ronan Ysebaert, Nicolas Lambert, Elina Marveaux"
format:
  html:
    embed-resources: true
    smooth-scroll: true
    fontsize: 0.9em
    toc: true
    toc-depth: 2
    toc-title: "."
    bibliography: [bib.bib]
    crossrefs-hover: false
    theme: [yeti, style.scss]
execute:
  warning: false
  message: false 
knitr:
  opts_chunk:
    out.width: "100%"
editor_options: 
  chunk_output_type: console
editor: 
  markdown: 
    wrap: 72
---

![](img/header.png)

::: {.callout-note}
Ce support est inspir√© en de nombreux points du manuel [G√©omatique avec R](https://rcarto.github.io/geomatique_avec_r/) [@giraud2024].  Et on les en remercie chaleureusement üôè. 
:::

Ce document montre les solutions techniques pour **importer**, **explorer**, **manipuler**, **visualiser** (simplement) et **exporter des donn√©es g√©ographiques avec R** :

- En **partant de rien**. 
- Avec des **tableaux de donn√©es comprenant une dimension g√©ographique** (identifiant g√©ographique).
- Avec des **couches d'information g√©ographique** (vecteur et raster).
- En utilisant des solutions des packages interfa√ßant des **API** (*Application Programming Interface*).
- En mobilisant des packages interfa√ßant **OpenStreetMap (OSM)**. 

Les exemples propos√©s sont tant√¥t adapt√©s aux contexte tunisien ou au contexte africain. 


### Packages utilis√©s

- **`readxl`** : importer des fichiers Excel.
- **`plotly`** : cr√©er des graphiques interactifs. 
- **`sf`** : importer, manipuler et exporter des donn√©es g√©ographiques vectorielles.
- **`terra`** : importer, manipuler et exporter des fichiers raster. 
- **`leaflet`** : r√©aliser une carte interactive.
- **`geodata`** : acc√©der √† des jeux de donn√©es g√©ographiques de r√©f√©rence dans le monde. 
- **`rnaturalearth`** : acc√©der √† des fonds de carte du Monde.
- **`wbstats`** : utiliser les jeux de donn√©es de la Banque Mondiale via son API. 
- **`osmextract`** : t√©l√©charger des donn√©es OpenStreetMap.
- **`osrm`** : calculer des temps de parcours routiers via l'engin de routage OSRM. 

Si vous n‚Äôavez pas ces packages, vous pouvez les installer en ex√©cutant la ligne suivante dans la console.

```{r}
#| eval: false

install.packages(c('readxl',  'sf', 'terra', 'leaflet', 'geodata',  'wbstats', 
                   'rnaturalearth', 'osmextract', 'osrm', 'plotly'))
```

<br>

# From scratch

En partant de rien et avec quelques lignes de code on peut cr√©er un jeu de donn√©es spatial pour en faire, par exemple, une carte interactive. 

Trois vecteurs sont cr√©√©s, puis transform√©s en `data.frame` et enfin convertis en objet spatial avec la fonction `st_as_sf()` du package `sf`. Cela permet de cr√©er rapidement une carte interactive avec le package `leaflet`. 

```{r}
# 3 vecteurs avec nom, longitude et latitude
name <- c("Sentido Bellevue Park", "Universit√© de Sfax")
long <- c(10.579, 10.742)
lat <- c(35.913, 34.736)

# Transformer en data.frame
loc <- data.frame(name, long, lat)

# Transformer en objet spatial
library(sf)
loc <- st_as_sf(loc, 
                coords = c("long", "lat"),
                crs = 4326)

# Visualiser simplement avec leaflet
library(leaflet)

leaflet(loc) |> 
  addTiles() |> 
  addCircleMarkers(popup = loc$name) # H√¥pitaux

```


<br>

# Tableaux de donn√©es

## Fichiers .csv

Import des donn√©es des d√©l√©gations au format csv. On lui donne le nom de `del_df`.

```{r}
del_df <- read.csv("data/tun/don_del.csv", sep = ";", dec = ",")
```

Avec R, il est tr√®s important de ma√Ætriser la nature des objets import√©s ou transform√©s, et les convertir le cas √©ch√©ant. La fonction `class()` nous permet de constater qu'il s'agit d'un `data.frame`. La fonction `str()` permet de d√©tailler son contenu.  

```{r}
class(del_df)
str(del_df)
```

On visualise les premi√®res lignes avec la fonction `head()`.

```{r}
head(del_df, 5)
```


## Fichiers Excel

La package `readxl` permet l'import de fichiers Excel. La fonction `read_excel` a plusieurs arguments utiles pour sp√©cifier en entr√©e le format des colonnes (texte, num√©rique), ne pas consid√©rer les *n* premi√®res lignes du fichier, etc. 

Nous importons ici un fichier Excel d√©riv√© du [*World Population Prospects*](https://population.un.org/wpp/Download/Standard/Population/) des Nations Unies, qui met √† disposition toute sorte d‚Äôindicateurs d√©mographiques (population, natalit√©, mortalit√©). On dispose ici des d√©nombrements de population par tranche d‚Äô√¢ge quinquennale de 1950 √† 2021 (feuille *estimates*).

```{r}
library(readxl)

world <- read_excel("data/world/WPP2022_POP_F02_1_POPULATION_5-YEAR_AGE_GROUPS_BOTH_SEXES.xlsx", 
                 sheet = "Estimates",
                 skip = 16,
                 col_types = c(rep("text", 10), rep("numeric", 22))) 
```

## Manipulation de `data.frame`

Dans les faits ces fichiers n√©cessitent g√©n√©ralement d'√™tre reformat√©s et r√©organis√©s pour pouvoir √™tre interpr√©t√©s dans un logiciel quel qu'il soit... Commen√ßons par comprendre la structure des donn√©es : noms de colonnes, ann√©es disponibles etc.

```{r}
# Conversion en data.frame
world <- data.frame(world)

# Nom des colonnes
colnames(world)

# Ann√©es disponibles
unique(world$Year)
```

On peut alors filtrer les dimensions du tableau, calculer des indicateurs, etc. qui pourront √™tre utilis√©s pour des statistiques de base, des graphiques voire de futures repr√©sentations cartographiques.

```{r}
# Somme de plusieurs colonnes
world$POP_TOT <- rowSums(world[,c(12:32)]) # Population totale

# Renommer une colonne
names(world)[3] <- "Name"

# Cr√©er des indicateurs
# Part des jeunes
world$YOUNG_RT <- (world$X0.4 + world$X5.9 + world$X10.14) / world$POP_TOT * 100 
# Part des personnes √¢g√©es
world$OLD_RT <- (world$X65.69 + world$X70.74 + world$X75.79 + world$X80.84 +
                   world$X85.89 + world$X90.94 + world$X95.99) / world$POP_TOT * 100 

# S√©lection d'une ligne
df <- world[world$Year == 2021,] # Ann√©e de r√©f√©rence

# S√©lectionner plusieurs lignes
afr <- c("910", "911", "912", "913", "914")
df <- df[df$Parent.code %in% afr,] # Pays africains

# Ordonner selon les valeurs d'une colonne
df <- df[order(df$YOUNG_RT, decreasing = TRUE),]
```

Il existe de nombreuses fonctions pour l'analyse statistique avec R. La plus basique √©tant probablement `summary()`. 

```{r}
# R√©sum√© stat
summary(df)
```


## Repr√©sentations graphiques

Les possibilit√©s offertes en terme de repr√©sentations graphiques sont nombreuses avec R ! Car c'est aussi un langage qui a √©t√© cr√©√© pour cela. 

### De base 

En une ligne de code on peut cr√©er des repr√©sentations graphiques vari√©es, adapt√©es √† la nature statistique des variables √† explorer. 

```{r}
par(mar = c(2,2,2,2), mfrow = c(2, 3))

barplot(df$YOUNG_RT, main = "Diagramme en barre")
boxplot(df$YOUNG_RT, main = "Bo√Ætes √† moustache")
hist(df$YOUNG_RT, main = "Histogrammes")
hist(df$YOUNG_RT, freq = FALSE, main = "Histogrammes et densit√©")
lines(density(df$YOUNG_RT), col = "blue")
stripchart(df$YOUNG_RT, method = "jitter", pch = 16,
           main = "Diagrammes de dispersion")
plot(data = df, YOUNG_RT ~ OLD_RT, main = "Nuages de points")
```

Ces graphiques sont param√©trables avec une s√©rie d'arguments graphiques.   

```{r}
par(mar = c(4,4,0,4))

# Line plot
tun <- world[world$Name == "Tunisia",]
alg <- world[world$Name == "Algeria",]
mar <- world[world$Name == "Morocco",]

plot(alg$Year, # Abscisses 
     alg$YOUNG_RT, # Ordonn√©es
     type = "l", # Type lignes
     ylim = c(20, 50), # Bornes min/max des ordonn√©es
     cex = .6, # Taille des points
     col = "blue", # Couleur de la ligne
     cex.lab = 0.7, # R√©duit les labels d'un facteur de 0.7
     cex.axis = 0.6, # R√©duit les labels des graduations d'un facteur de 0.6 
     xlab = "Ann√©es", # Label abscisses 
     ylab = "Part des jeunes (%) dans la population totale") # Label ordonn√©es

lines(mar$Year, 
      mar$YOUNG_RT, # Rajouter une ligne (Maroc)
      col = "darkgreen", 
      type = "l",
      cex = .6)

lines(tun$Year,  # Et Tunisie
      tun$YOUNG_RT, 
      type = "l", 
      cex = .6,
      col = "red")

# Organisation de la l√©gende
legend(x = "topright",
       legend = c("Alg√©rie", "Maroc", "Tunisie"),
       col = c("blue", "darkgreen", "red"), lty = 1,
       cex = .8)
```


## Graphiques interactifs

Le package `plotly` [@R-plotly] permet d'int√©grer une dimension interactive aux repr√©sentations graphiques. Pour utiliser les fonctions de ce package, il faut bien avoir en t√™te le format de donn√©es attendues (format long). 

```{r}
library(plotly)

# Importer jeu de donn√©es d'exemple de gapminder
df <- read.csv("data/world/gapminder.csv")

head(df)

# Cr√©er un graphique de type "Multiple Trace Animations"
fig <- df %>%
  plot_ly(
    x = ~gdpPercap, 
    y = ~lifeExp, 
    size = ~pop, 
    color = ~continent, 
    frame = ~year, 
    text = ~country, 
    hoverinfo = "text",
    type = 'scatter',
    mode = 'markers'
  )

# Param√©trer l'√©chelle, les labels, etc.
fig <- fig %>% layout(
    xaxis = list(type = "log", title = "PIB par habitant"),
    yaxis = list(title = "Esp√©rance de vie")
  )


fig
```


:::{.callout-note title="Pour aller plus loin"}

Consulter [r-graph-gallery](https://r-graph-gallery.com/index.html) qui pr√©sente les possibilit√©s graphiques les plus courantes, en langage de base R. L'exploration de la syntaxe `ggplot`et son package √©ponyme [ggplot2](https://ggplot2.tidyverse.org/index.html) peut √™tre utile pour la recherche de repr√©sentations graphiques avanc√©es. Cette syntaxe est un peu diff√©rente du langage de base R et repose sur les principes de la "grammaire des graphiques". Plusieurs manuels tr√®s bien construits permettent de rentrer dans l'univers de la visualisation de donn√©es avec `ggplot2`, comme [Modern Data Visualization with R](https://rkabacoff.github.io/datavis/) [@kabacoff]    

:::

::: {.callout-tip collapse="true"}
## L'int√©r√™t de la programmation pour manipuler des donn√©es

Les fournisseurs de donn√©es institutionnels distribuent parfois des tableaux de donn√©es peu adapt√©s √† l'int√©gration dans un logiciel quel qu'il soit. La mise en forme des donn√©es dans un langage de programmation permet : 

- d'√©viter d'avoir √† manipuler ces fichiers manuellement, source d'erreurs.
- d'avoir un fa√ßon g√©n√©rique et rapide d'importer un grand nombre de tableaux de donn√©es (et √©viter de perdre de nombreuses heures de travail).

Voici un exemple adapt√© aux donn√©es de ch√¥mage par gouvernorats tunisiens produit par l'Institut National de la Statistique tunisien (INS). Le fichier brut ressemble √† ceci :

![](img/data_chom_gouv.png)

Un court bloc de code permet de r√©organiser le fichier comme d√©sir√©, et pourrait √™tre utilement √©tendu aux autres fichiers distribu√©s par l'INS. 

```{r}
# Import
df <- read_excel("data/tun/chomage.xls", # Chemin du fichier
                 sheet = "Sheet1", # Nom de la feuille Excel
                 skip = 3, # Retirer les trois premi√®res lignes
                 col_types = c(rep("text", 3), rep("numeric", 6))) # Format des colonnes 

# Table de passage Recensement / codes internationaux
gouv <- read.csv("data/tun/table_GADM_TUN.csv")

# Reformatage
df <- data.frame(df)
df[,1:2] <- NULL # Retirer les deux premi√®res colonnes

# Noms de colonnes
cols <- c("CHOM_INS_NON_", "CHOM_INS_PRI_", "CHOM_INS_SEC_", "CHOM_INS_SUP_",
          "CHOM_INS_UNK_", "CHOM_INS_TOT_") 
colnames(df)[1] <- "id_TUN"

# Ch√¥meurs
# Hommes
df1 <- df[c(1:25),]
names(df1)[2:length(df1)] <- paste0(cols, "M")
gouv <- merge(gouv, df1, by = "id_TUN", all.x = TRUE)

# Femmes
df2 <- df[c(26:50),]
names(df2)[2:length(df2)] <- paste0(cols, "F")
gouv <- merge(gouv, df2, by = "id_TUN", all.x = TRUE)

# Total
df3 <- df[c(51:75),]
names(df3)[2:length(df3)] <- paste0(cols, "T")
gouv <- merge(gouv, df3, by = "id_TUN", all.x = TRUE)

head(gouv)
```

Une fois mis en forme, on peut r√©aliser un graphique **sans avoir modifi√© le fichier initial provenant de l'INS**. 

```{r}
#| fig-cap: "Nombre de ch√¥meurs dans les gouvernorats tunisiens par niveau d'√©ducation"
# 2 graphiques par ligne
par(mfrow = c(1,2), mar = c(2,2,2,2))

# Boxplot hommes
boxplot(gouv$CHOM_INS_NON_M, # Ch√¥meurs hommes par niveau d'instruction
        gouv$CHOM_INS_PRI_M, 
        gouv$CHOM_INS_SEC_M,
        gouv$CHOM_INS_SUP_M, 
        ylim = c(0, 12000), # Bornes min/max de l'axe des ordonn√©es
        main = "Hommes", # Titre plot
        names = c("Rien", "Primaire", "Secondaire", "Tertiaire"), # Labels (X)
        ylab = "Nombre de ch√¥meurs, 2014", # Label (Y)
        col = "#adcaf7", # Couleur des box-plots
        cex.axis = .6, # Taille des labels des axes (r√©duit de 70 %)
        cex.title = .6) # Taille du label du titre (r√©duit de 70 %)

# Boxplot femmes
boxplot(gouv$CHOM_INS_NON_F, 
        gouv$CHOM_INS_PRI_F, 
        gouv$CHOM_INS_SEC_F,
        gouv$CHOM_INS_SUP_F,
        ylim = c(0, 12000),
        main = "Femmes",
        names = c("Rien", "Primaire", "Secondaire", "Tertiaire"), 
        col = "#ed9fb0", 
        cex.axis = .6, 
        cex.title = .6)
```

:::

## Export

`write.csv()` exporte un `data.frame` selon un chemin sp√©cifi√©. 

```{r}
#| eval: false

write.csv(x = gouv, # Objet √† exporter
          dsn = "data/tun/gouv_chom.csv", # Chemin de fichier 
          row.names = FALSE) # Pour retirer les num√©ros de ligne
```

<br>

# Donn√©es vectorielles

Le package [`sf`](https://r-spatial.github.io/sf/) permet d'importer et manipuler des couches g√©ographiques vectorielles (points, lignes, polygones). 

## Import

Le [geopackage](https://kost-ceco.ch/cms/kad_geopackage_fr.html#:~:text=1.2.1-,Description,.opengeospatial.org%2F) est un format de donn√©es ouvert  qui permet de stocker plusieurs couches g√©ographiques dans un m√™me fichier. La fonction `st_layers()` permet d‚Äôavoir un aper√ßu des couches pr√©sentes dans un fichier geopackage.  

```{r}
library(sf)

st_layers("data/tun/geom/tun_admin.gpkg")
```

Importer des couches g√©ographiques avec `st_read()`. Il s'agit ici des couches g√©ographiques cr√©√©es il y a quelques ann√©es par l'UAR RIATE. 
```{r}
del <- st_read("data/tun/geom/tun_admin.gpkg", layer = "delegation", quiet = TRUE)
gouv <- st_read("data/tun/geom/tun_admin.gpkg", layer = "gouvernorat", quiet = TRUE)
reg <- st_read("data/tun/geom/tun_admin.gpkg", layer = "region", quiet = TRUE)
```

Il s'agit bien d'objets `sf`. 

```{r}
class(del)
```

La fonction `st_read()` peut aussi √™tre employ√©e pour des formats de fichiers .geojson, .shapefiles, etc. 

```{r}
reg <- st_read("data/tun/geom/map_reg.geojson", quiet = TRUE) 
```

Les objets `sf` sont des `data.frame` dont l‚Äôune des colonnes contient des g√©om√©tries. Cette colonne est de la classe `sfc` (simple feature column) et chaque individu de la colonne est un `sfg` (simple feature geometry).

Ce format est tr√®s pratique dans la mesure o√π les donn√©es et les g√©om√©tries sont intrins√®quement li√©es dans un m√™me objet. Des informations additionnelles, propres aux couches d'informations g√©ographiques sont aussi restitu√©es (type de g√©om√©trie, emprise spatiale, syst√®me de coordonn√©es de r√©f√©rence). 

```{r}
head(del)
```

Aper√ßu des variables avec `plot()` :

```{r}
plot(del)
```

Afficher juste les g√©om√©tries:

```{r}
#| fig-height: 4

# 3 cartes par ligne
par(mfrow = c(1,3), mar = c(2,2,2,2))

# D√©l√©gations
plot(del$geom, # G√©om√©tries uniquement
     col = "peachpuff", # Couleur du fond
     border = "white", # Couleur de bordure
     main = "D√©l√©gations") # Titre

# Gouvernorats
plot(gouv$geom, 
     col = "peachpuff", 
     border = "white",
     main = "Gouvernorats")

# "R√©gions"
plot(reg$geom, 
     col = "peachpuff",
     border = "white",
     main = "R√©gions")
```


## Jointures attributaires

Nous pouvons joindre un `data.frame` √† un objet `sf` en utilisant la fonction `merge()` et en s‚Äôappuyant sur des identifiants communs aux deux objets.

Attention √† l‚Äôordre des arguments, l‚Äôobjet retourn√© sera du m√™me type que `x`. Il n‚Äôest pas possible de faire une jointure attributaire en utilisant deux objets `sf`.

```{r}
del <-  merge(
  x = del[,"del_code"],  # L'objet sf (seulement le champ del_code)
  y = del_df,          # le data.frame
  by.x = "del_code",  # identifiant dans x
  by.y = "del_code",  # identifiant dans y
  all.x = TRUE         # conserver toutes les lignes
)

head(del)
plot(del[,"idr_2011"])
```


## S√©lectionner des lignes, des colonnes

Les objets `sf` sont des `data.frame`, on peut donc s√©lectionner leur lignes et leur colonnes de la m√™me mani√®re.

```{r}
# S√©lection de lignes
sou <- del[del$gou_nom == "Sousse",]

# S√©lection de colonnes
sou <- sou[,"idr_2011"]

# Ne conserver que les lignes avec une valeur
sou <- sou[!is.na(sou$idr_2011),]

plot(sou[,"idr_2011"])
```


## Export d'une couche g√©ographique

```{r}
#| eval: false
st_write("data/sousse_deleg.geojson")
```

<br>

# Donn√©es raster

Le package `terra` [@R-terra] permet d‚Äôimporter et d‚Äôexporter des fichiers raster. Il repose sur la biblioth√®que GDAL [@GDAL] qui permet de lire et de traiter un tr√®s grand nombre de format d‚Äôimages g√©ographiques.

## Import 

La fonction `rast()` permet de cr√©er et/ou d‚Äôimporter des donn√©es raster. Nous importons ici un jeu de donn√©es au format .tif cr√©√© et distribu√© par [WorldPop](https://hub.worldpop.org/geodata/summary?id=29291) qui porte sur une estimation de la population tunisienne dans une r√©solution de 100 m√®tres. 

```{r}
library(terra)
pop <- rast("data/tun/raster/tun_ppp_2020_UNadj.tif")
```

Ce sont des objets de type `SpatRaster`. 

```{r}
pop
```

La fonction `summary()` est toujours utile pour un r√©sum√© statistique des cellules. Vu le nombre important de cellules, ce r√©sum√© est effectu√© sur un √©chantillon. 

```{r}
summary(pop)
```


## Affichage

Par d√©faut et comme montr√© pr√©c√©demment, la fonction `plot()` renvoie une l√©gende continue sur les repr√©sentations cartographiques. On peut choisir de discr√©tiser cette information pour repr√©senter des classes de valeur associ√©e √† une palette de couleurs personnalis√©e. 

```{r}
par(mfrow = c(1,2))

# Graphique en √©chelle continue
plot(pop)

# Avec discr√©tisation et param√©trage des couleurs
cuts <- c(0, 1, 2, 4, 8, 16, 32, 64, 235)
cols <- colorRampPalette(c("yellow", "darkgoldenrod1", "brown1"))
plot(pop, breaks = cuts, col = cols(8))
```


## Modification de la zone d'√©tude

Le d√©coupage d‚Äôun raster en fonction de l‚Äô√©tendue d‚Äôun autre objet, SpatVector ou SpatRaster, est r√©alisable avec la fonction `crop()`. Les deux couches de donn√©es doivent √™tre dans la m√™me projection.

```{r}
# Transformer en WGS 84
sou <- st_transform(sou, 4326)

# Crop avec la d√©l√©gation de Sousse
pop_sou <- crop(pop, sou)

# Plot
plot(pop_sou, breaks = cuts, col = cols(8))
plot(sou$geometry, col = NA, add = TRUE)
```

## Export

La fonction `writeRaster()` permet d‚Äôenregistrer un objet `SpatRaster`.

```{r}
#| eval: false
writeRaster(x = pop_sou, filename = "data/tun/raster/pop_sou.tif")
```

<br>

# Packages de donn√©es spatiales

De nombreux packages distribuent des donn√©es g√©ographiques. Ils interfacent souvent des API qui permettent d'interroger des donn√©es mises √† disposition sur le Web, directement avec R.

L'int√©r√™t des API est de se connecter directement aux bases de donn√©es des fournisseurs de donn√©es, et de disposer des derni√®res mises √† jour des donn√©es. 

::: {.callout-tip collapse="true"}

## Principaux packages

### Au niveau international

- `rnaturalearth` [@R-rnaturalearth] : permet de r√©cup√©rer les donn√©es cartographiques [Natural Earth](https://www.naturalearthdata.com/).   
- `cshapes` [@R-cshapes] : met √† disposition les fronti√®res nationales, de 1886 √† aujourd'hui.  
- `geonames` [@R-geonames] : permet d'interroger la BD [geonames](http://www.geonames.org/), qui fournit notamment des localisations.
- `wbstats` [@R-wbstats] et `WDI` [@R-WDI] : donnent acc√®s aux donn√©es et statistiques de la Banque mondiale.   
- `sen2r` [@R-sen2r] : permet de t√©l√©charger et pr√©traiter automatiquement les donn√©es du satellite Sentinel-2.   
- `MODIStsp` [@R-MODIStsp] : permet de trouver, t√©l√©charger et traiter des images *MODIS*.
- `geodata` [@R-geodata] : fournit un acc√®s √† des [donn√©es](https://github.com/rspatial/geodata) sur le climat, l'altitude, le sol, la pr√©sence d'esp√®ces et les limites administratives. 
- `elevatr` [@R-elevatr] : donne acc√®s √† des donn√©es d'√©l√©vation mises √† disposition par [*Amazon Web Services Terrain Tiles*](https://registry.opendata.aws/terrain-tiles/), l'[*Open Topography Global Datasets API*](https://opentopography.org/developers/) et l'[*USGS Elevation Point Query Service*](https://nationalmap.gov/epqs/).
- `rgee` [@R-rgee] : permet d'utiliser l'API de [Google Earth Engine](https://www.google.com/intl/fr_in/earth/education/tools/google-earth-engine/), catalogue de donn√©es publiques et infrastructure de calcul pour les images satellites.   
- `nasapower` [@R-nasapower] : API client *NASA* (pr√©vision des ressources √©nerg√©tiques mondiales, m√©t√©orologie, √©nergie solaire de surface et climatologie). 
- `geoknife` [@R-geoknife] : permet de traiter (en ligne) des donn√©es matricielles volumineuses issues du *Geo Data Portal* de l'*U.S. Geological Survey*.
- `rdhs` [@R-rdhs] : API client et gestions de donn√©es de l'[enqu√™te d√©mographique et de sant√© (DHS)](https://dhsprogram.com/).
- `giscoR` [@R-giscoR] : permet de t√©l√©charger des donn√©es cartographiques mondiales et europ√©ennes de la BD [GISCO](https://ec.europa.eu/eurostat/web/gisco) d'Eurostat (syst√®me d'information g√©ographique de la Commission). 
- `eurostat` [@R-eurostat] : permet de t√©l√©charger des donn√©es de la BD [Eurostat](https://ec.europa.eu/eurostat).    
  

### Au niveau national

- **Br√©sil**
  - `geobr` [@R-geobr] : fournit un acc√®s facile aux s√©ries de donn√©es spatiales officielles du Br√©sil pour diff√©rentes ann√©es et d√©coupage administratifs. 
- **Chili**
  -`chilemapas` [@R-chilemapas] : donne acc√®s aux  divisions politiques et administratives du Chili. 
- **Espagne** 
  - `mapSpain` [@R-mapSpain] : propose les limites administratives de l'Espagne √† plusieurs niveaux (Communaut√©s autonomes, Provinces, Municipalit√©s), ainsi que des tuiles.
- **√âtats-Unis**
  - `tidycensus` [@R-tidycensus] : permet de charger des donn√©es et g√©om√©tries du recensement am√©ricain en format `sf` et `tidyverse`
  - `tigris` [@R-tigris] : donne acc√®s aux √©l√©ments cartographiques fournis par le US Census Bureau TIGER, y compris les limites cartographiques, les routes et l'eau.
  - `FedData` [@R-FedData] : automatise le t√©l√©chargement de donn√©es g√©ospatiales disponibles √† partir de plusieurs sources de donn√©es f√©d√©r√©es.
  - `acs` [@R-acs] : permet de t√©l√©charger et manipuler les donn√©es de l'*American Community Survey* et les donn√©es d√©cennales du recensement des √âtats-Unis.
  - `censusapi` [@R-censusapi] : wrapper pour les API du *Census Bureau* des √âtats-Unis.
  - `idbr` [@R-idbr] : interface avec l'API de la base de donn√©es internationale du US Census Bureau.  
  - `ipumsr` [@R-ipumsr] : Permet d'importer des donn√©es de recensement, d'enqu√™te et g√©ographiques fournies par l'[IPUMS](https://www.ipums.org/).
  - `totalcensus` [@R-totalcensus] : permet d'extraire les donn√©es du recensement d√©cennal et de l'*American Community Survey* au niveaux des *block*, *block group* et *tract*.
- **Finland**
  - `mapsFinland` [@R-mapsFinland] : donne un acc√®s √† des cartes et donn√©es concernant la Finland.
- **France**
  - `happign` [@R-happign] : acc√®s √† certaines donn√©es de l'IGN.
  - `insee` [@R-insee] : pour t√©l√©charger facilement les donn√©es de la base BDM ([Banque de Donn√©es Macro√©conomiques](https://www.data.gouv.fr/fr/reuses/insee-package-r/)) de l'INSEE.
- **Pologne**
  - `rgugik` [@R-rgugik] : permet l'acquisition automatique de donn√©es ouvertes √† partir des ressources du Bureau central polonais de la g√©od√©sie et de la cartographie ([G≈Ç√≥wny UrzƒÖd Geodezji i Kartografii](https://www.gov.pl/web/gugik) ).  
- **Uruguay**
  - `geouy` [@R-geouy] : permet le chargement d'informations g√©ographiques sur l'Uruguay.
- ...

:::

## geodata

Ce package facilite l'acc√®s √† des donn√©es g√©ographique de r√©f√©rence sur le climat, la couverture du sol, les limites administratives et plusieurs autres jeux de donn√©es de r√©f√©rence au niveau mondial. 

::: {.callout-note collapse="true"}

## Les couches g√©ographiques inclues dans le package `geodata`

|Function                        |Description                                                                                                     |
|:---------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------|
|`bio_oracle`                 |Marine data from [Bio-Oracle](https://bio-oracle.org/) |
|`cmip6_world`, `cmip6_tile`  |Downscaled and calibrated CMIP6 projected future climate data                            |
|`country_codes`                |Country codes                                                                |
|`crop_calendar_sacks`          |Crop calendar data by [Sacks et al](https://sage.nelson.wisc.edu/data-and-models/datasets/crop-calendar-dataset/)     |
|`crop_monfreda`                |Crop area and yield data for 175 crops by [Monfreda et al.](http:://www.earthstat.org/harvested-area-yield-175-crops/)    |
|`crop_spam`                    |[MapSPAM](https://www.mapspam.info/data/) crop data (area, yield, value)     |
|`cropland`                       |Cropland density for the world derived from different sources (ESA, GLAD, QED) |
|`elevation_3s`, `elevation_30s`, `elevation_global`       |Elevation data                                                                  |
|`gadm`, `world`   |Administrative boundaries for any country, or the entire world from [GADM](https://gadm.org) |
|`landcover`                    |Landcover data derived from ESA WorldCover |
|`footprint`                    |Human footprint data from the [Last of the Wild project](https://sedac.ciesin.columbia.edu/data/collection/wildareas-v3) |
|`osm`                          |OpenStreetMap data by country (places and roads) |
|`population`                   |Population density [Gridded Population of the World](http://sedac.ciesin.columbia.edu/data/collection/gpw-v4/documentation)    |
|`soil_af`            |Chemical and physical soil properties data for Africa for different soil depths  |
|`soil_af_elements`             |Connect to or download chemical soil element concentration (for the 0-30 cm topsoil) data for Africa  |
|`soil_af_water`                |Physical soil properties data for Africa for water balance computation  |
|`soil_af_isda`                 |Soil data for Africa derived from the [iDSA data set](https://envirometrix.nl/isdasoil-open-soil-data-for-africa/)   |
|`soil_world_vsi`               |Virtually connect to the global [SoilGrids](https://www.isric.org/explore/soilgrids) data        |
|`soil_world`                   |Global soils data from [SoilGrids](https://www.isric.org/explore/soilgrids) |
|`sp_occurrence`                |Species occurrence records from the [Global Biodiversity Information Facility](https::/www.gbif.org) |
|`travel_time`                  |Travel time to and from cities and ports by [Nelson et al.](https://www.nature.com/articles/s41597-019-0265-5)   |
|`worldclim_global`, `worldclim_country`, `worldclim_tile` |[WorldClim](https://worldclim.org) glocal climate data     |

:::

Extraction des couches g√©ographiques d'altitude et de temp√©rature en Tunisie. 

```{r}
#| eval: false

library(geodata)
elev <- elevation_30s(country = "TUN", path = tempdir())
temp <- worldclim_country(country = "Tunisia", 
                          res = 10, 
                          var = "tavg",
                          path = tempdir())
```

```{r}
#| echo: false

elev <- rast("data/tun/raster/elevation.tif")
temp <- rast("data/tun/raster/temperatures_mai_av.tif")
```

Ce sont des objets de type `SpatRaster`.

```{r}
class(temp)
class(elev)
```

```{r}
# Les afficher
par(mfrow = c(1,2))

# Altitude
cols <- colorRampPalette(c("#31ad37", "#f5f752", "#fca330", "#9c5903"))
plot(elev, main = "Altitude", col = cols(50))
     
# Temp√©rature
cols <- colorRampPalette(c("#4575b4", "#91bfdb", "#e0f3f8", 
                           "#fee090", "#fc8d59", "#d73027"))
plot(temp$TUN_wc2.1_30s_tavg_5, main = "Temp√©ratures, Mai (1970-2000)",
     col = cols(50))
```


## Natural Earth et Banque Mondiale.

::: {.callout-tip}
## Objectif

Nous cherchons ici √† cr√©er une carte des √©missions de CO¬≤ en Afrique en utilisant les donn√©es de la banque mondiale et le fond de carte Natural Earth. Rien besoin de t√©l√©charger, mais il faut une connexion internet. 

:::

Plusieurs fonds de carte des pays du Monde √† diff√©rents niveaux de g√©n√©ralisation cartographique sont disponibles avec la package `rnaturalearth`. Nous s√©lectionnons uniquement les pays africains. 

```{r}
library(rnaturalearth)

# Import des pays
country <- ne_countries(type = "countries", # pays
                        scale = "small",  # niveau de g√©n√©ralisation
                        returnclass = "sf") # objet retourn√©


# Conversion en projection Mercator
country <- st_transform(country, crs = "EPSG:3857")

# Si on s'int√©resse √† l'Afrique (mod√®le carto)
afr <- country[country$continent == "Africa",]
```

Le package `wbstats `permet d‚Äôinterroger l‚ÄôAPI de la base de donn√©es de la Banque Mondiale.  On peut faire une recherche pour trouver le nom des tables qui r√©pondent √† une requ√™te par mots-cl√©s avec la fonction `wb_search()`.

```{r}
library(wbstats)

wb_search("CO2 emissions")
```

La fonction `wb_data()` extrait les tables identifi√©es pour pour construire l'indicateur d'√©missions de CO¬≤ par habitant. La s√©rie statistique est disponible de 1960 √† 2023. 

::: {.callout-warning}
Chaque package reposant sur une API a son fonctionnement propre. Il est donc conseill√© de consulter attentivement la documentation associ√©e √† ces packages (souvent pr√©cise) pour apprendre √† les utiliser. 
:::

```{r}
# S√©lection des indicateurs
my_indicators = c("pop" = "SP.POP.TOTL",
                  "co2" = "EN.ATM.CO2E.KT")

# Interroger l'API
wb <- wb_data(my_indicators, return_wide = FALSE)

head(wb)
# Ann√©es disponibles
unique(wb$date)
```

Nous gardons la derni√®re ann√©e pour laquelle les √©missions de CO¬≤ sont disponibles 2020. La fonction `reshape()` est utilis√©e pour transformer le `data.frame` dans un format attendu (long vers large).

```{r}
# S√©lectionner la derni√®re ann√©e disponible et les colonnes utiles
wb <- wb[wb$date %in% 2020,]
wb <- wb[,c("iso3c", "indicator_id", "value")]
wb <- data.frame(wb)

# Formatage (format long + concat√©nation code indicateur + ann√©e ref
wb <- reshape(wb, idvar = "iso3c", timevar = "indicator_id", direction = "wide")

# Renommage des colonnes et cr√©ation de l'indicateurs √©missions par hab
names(wb)[2:3] <- c("co2_2020", "pop_2020")
wb$co2_hab_2020 <- wb$co2_2020 * 1000 / wb$pop_2020
```

La jointure attributaire avec le fond de carte pr√©c√©demment import√© avec `rnaturalearth` permet ainsi de constater que tout est en place pour proc√©der √† une repr√©sentation cartographique du ph√©nom√®ne. 

```{r}
# Jointure attributaire
afr <- merge(afr[,c("adm0_a3", "name_fr")], wb, 
             by.x = "adm0_a3", by.y = "iso3c", all.x = TRUE) 

# Carte
plot(afr[,"co2_hab_2020"])
```


# OpenStreetMap

OpenStreetMap (OSM) est un projet de cartographie participative qui a pour but de constituer une base de donn√©es g√©ographiques libre √† l‚Äô√©chelle mondiale. OSM vous permet de voir, modifier et utiliser des donn√©es g√©ographiques dans le monde entier.

Plusieurs packages permettre d'extraire, interroger et visualiser des donn√©es issues d'OSM :

- `osmextract` [@R-osmextract] : permet d'importer des donn√©es [OSM](https://www.openstreetmap.org/).   
- `osmdata` [@R-osmdata] : pour t√©l√©charger et utiliser les donn√©es d'OSM, en utilisant l'API [Overpass turbo](https://wiki.openstreetmap.org/wiki/Overpass_turbo).
- `maptiles` [@R-maptiles] : Ce package t√©l√©charge, compose et affiche des tuiles √† partir d'un grand nombre de fournisseurs (*OpenStreetMap*, *Stadia*, *Esri*, *CARTO* ou *Thunderforest*...).   
- `nominatimlite` [@R-nominatimlite] et `tidygeocoder` [@R-tidygeocoder] : Des g√©ocodeurs qui utilisent OSM, notamment. 

::: {.callout-tip}
## Objectif

Dans un premier temps nous cherchons √† **extraire d'OSM** les g√©om√©tries suivantes en Tunisie :

- **D√©coupages administratifs** : D√©l√©gations et secteurs. 
- **√âquipements** : objets d√©crits avec une cl√© OSM *amenity* (√©quipements utiles et importants). 

A partir de ces donn√©es extraites, nous proposons ensuite de **calculer les temps de parcours routiers** des **centres de secteur** vers **l'h√¥pital ou la clinique la plus accessible**. 
::: 

## Extraction et pr√©paration des donn√©es

Le package `osmextract` [@R-osmextract] permet d‚Äôextraire des donn√©es depuis une base de donn√©es OSM directement et travailler en local sur des volumes de donn√©es tr√®s importants et ainsi d‚Äô√©viter de surcharger un serveur Overpass turbo (utilis√© par le package `osmdata`).

### D√©coupages administratifs

La fonction `oe_get()` permet de t√©l√©charger un extrait de la base de donn√©es OSM pour une zone particuli√®re et un type d‚Äôobjet g√©ographique. L‚Äôargument `place` correspond au nom du fichier *.pbf accessible sur le site [Geofabrik](http://download.geofabrik.de/). L‚Äôargument `extra_tag` permet de s√©lectionner les objets de la base OSM correspondant √† une cl√© particuli√®re (se r√©f√©rer √† [la documentation d‚ÄôOSM](https://wiki.openstreetmap.org/wiki/FR:%C3%89l%C3%A9ments_cartographiques) pour choisir les cl√©s).

On commence par extraire tous les polygones et les points OSM inclus en Tunisie. L'import d'`extra_tags` permet d'obtenir des informations suppl√©mentaires qui serviront √† filtrer la base de donn√©es. 

```{r}
#| eval: false
library(osmextract)
osm_poly <- oe_get(place = "Tunisia",
                   layer = "multipolygons",
                   extra_tags = c("amenity", "ref:tn:hasc_2", "ref:tn:codegeo",
                                  "name:fr", "name:ar"))

osm_pt <- oe_get(place = "Tunisia",
                 layer = "points",
                 extra_tags = c("amenity", "name:fr", "name:ar"))
```

On peut ensuite filtrer l'extraction en fonction des objets / champs d'int√©r√™t. 

```{r}
#| eval: false
# D√©l√©gations et secteurs
admin <- osm_poly[!is.na(osm_poly$admin_level),] # Retirer pas d'attribut de niveau hi√©rarchique
deleg <- admin[admin$admin_level == 5,] # D√©l√©gations
sect <- admin[admin$admin_level == 6,] # Secteurs

# Ne garder que les champs utiles
deleg <- deleg[,c("osm_id", "ref_tn_codegeo", "ref_tn_hasc_2", "name_ar",  
                  "name_fr", "admin_level")]
sect <- sect[,c("osm_id", "ref_tn_codegeo", "name_ar",  
                  "name_fr", "admin_level")]
```

Ce bloc de code, dont on ne d√©taillera pas le contenu ici, permet d'harmoniser le nom des champs entre les couches g√©ographiques et de disposer des d√©l√©gations et gouvernorats d'appartenance des couches g√©ographiques des secteurs et d√©l√©gations. 

```{r}
#| eval: false

# D√©l√©gation d'appartenance du secteur
sect_pt <- st_centroid(sect) # Centroid du secteur
sect_pt <- st_intersection(sect_pt, deleg) # Intersection avec couche d√©l√©gation
sect_pt <- st_set_geometry(sect_pt, NULL) # Retirer g√©om√©tries
sect <- merge(sect, # Enrichir les secteurs du code d'appartenance de la d√©l√©gation
              sect_pt[,c("osm_id", "ref_tn_hasc_2")], 
              by = "osm_id", 
              all.x = TRUE)
sect <- sect[!duplicated(sect$osm_id),] # Retirer valeurs dupliqu√©es

# Renommer colonnes
names(sect)[2] <- "id_tn"
names(sect)[6] <- "id_hasc_deleg"
sect$id_hasc_gouv <- substr(sect$id_hasc_deleg, 1, 5) # Gouvernorat d'appartenance
names(sect)[2,6] <- (c("tn_codegeo", "int_codegeo"))
names(deleg)[2:3] <- c("id_tn", "id_hasc_deleg")
deleg$id_hasc_gouv <- substr(deleg$id_hasc_deleg, 1, 5)
```

### √âquipements

Les objets d√©crits par la cl√© *amenity* sont de nature h√©t√©rog√®nes (points, polygones). Ce bloc de code extrait les centroides des polygones et les associent √† la couche de points initiale. 

Ces couches g√©ographiques sont finalement export√©es dans un geopackage `tun_osm.gpkg`.

```{r}
#| eval: false

# Consolidation des g√©om√©tries
sel_poly <- osm_poly[!is.na(osm_poly$amenity),] # Retirer les objets qui n'ont pas de cl√© amenity
sel_pt <- osm_pt[!is.na(osm_pt$amenity),]
sel_poly <- st_make_valid(sel_poly) # Consolider les g√©om√©tries des polygones
sel_pt2 <- st_centroid(sel_poly) # extraire le centroide
cols <- intersect(names(sel_pt), names(sel_pt2)) # Garder les colonnes identiques
sel_pt <- rbind(sel_pt[,cols, sel_pt2[,cols]]) # Combiner points et polygones
sel_pt <- sel_pt[,c("osm_id", "amenity", "name_ar", "name_fr")]

# Exporter les couche ainsi cr√©√©es
st_write(sel_pt, "data/tun/geom/tun_osm.gpkg", layer = "poi")
st_write(deleg, "data/tun/geom/tun_osm.gpkg", layer = "deleg")
st_write(sect, "data/tun/geom/tun_osm.gpkg", layer = "sect")
```

:::{.callout-note title="Pour aller plus loin"}

Ce [document](https://rcarto.github.io/caRtosm/index.html) [@giraud2017] montre comment cr√©er un fond de carte avec des donn√©es OSM, extraire des objets d'int√©r√™t (bars et restaurants) avec le package `osmdata`. Il propose √©galement plusieurs pistes cartographiques pour manipuler et visualiser ces donn√©es. Notons simplement que la cartographie utilise les fonctions du package `cartography`, plus maintenu, et qu'il est conseill√© d'utiliser dor√©navant le package `mapsf`. 

:::

## R√©sultats de l'extraction

D√©nombrement des 15 objets OSM les plus fr√©quents d√©crits par la cl√© *amenity* en Tunisie.

```{r}
# Import des am√©nit√©s pr√©par√©es en amont
osm_pt <- st_read("data/tun/geom/tun_osm.gpkg", layer = "poi", quiet = TRUE)

# Nombre de points avec le tag "amenity". 
tbl <- table(osm_pt$amenity)
tbl <- tbl[order(tbl, decreasing = TRUE)]
tbl[1:15]

# On ne prend ici que les cliniques et h√¥pitaux
osm_pt <- osm_pt[osm_pt$amenity %in% c("clinic", "hospital"), ]
```

Nombre de d√©l√©gations, secteurs et cliniques/h√¥pitaux inclus dans OSM. 

```{r}
# Import des unit√©s territoriales pr√©par√©es en amont
deleg <- st_read("data/tun/geom/tun_osm.gpkg", layer = "deleg", quiet = TRUE)
sect <- st_read("data/tun/geom/tun_osm.gpkg", layer = "sect", quiet = TRUE)

# Nombre d'objets (lignes)
nrow(deleg)
nrow(sect)
nrow(osm_pt)
```

Le r√©sultat sous forme d'une carte interactive avec le package `leaflet`, qui sera pr√©sent√© ult√©rieurement dans la formation.  

```{r}
#| code-fold: true

# Choisir la palette
library(leaflet)
pal <- colorFactor(palette = c("red", "gold"),
                   domain = c("clinic", "hospital"))

# Cartographie interactive
leaflet(osm_pt) |> # Emprise = h√¥pitaux
  addProviderTiles("OpenStreetMap.HOT") |> # Type de tuiles charg√©es
  addPolygons(data = sect, # Secteurs
              col = "white",
              fillColor = "lightgrey",
              fillOpacity = 0.7,
              weight = 1,
              popup = paste0("<b>", sect$id_tn, "<br></b>",
                             sect$name_ar, "<br>", sect$name_fr),
              group = "Secteurs")|>
  addPolygons(data = deleg, # D√©l√©gations
              col = "darkgrey",
              fill = "lightgrey",
              fillOpacity = 0,
              weight = 1.2,
              popup = paste0("<b>", deleg$id_tn, " / ",
                             deleg$id_hasc_deleg,"<br></b>",
                             deleg$name_ar, "<br>", deleg$name_fr),
              group = "D√©l√©gations") |>
  addCircleMarkers(radius = 4, # H√¥pitaux
                   stroke = FALSE,
                   color = ~ pal(amenity),
                   fillOpacity = 1,
                   popup = paste0(osm_pt$name_ar, "<br>", osm_pt$name_fr),
                   group = "Cliniques et h√¥pitaux") |>
  addLegend(pal = pal, # L√©gende pour diff√©rencier cliniques et h√¥pitaux
            values = c("clinic", "hospital"),
            opacity = 0.7,
            title = "OSM amenity",
            position = "bottomright") |>
  addLayersControl(overlayGroups = c("Secteurs", "D√©l√©gations", "Cliniques et h√¥pitaux"),
                   options = layersControlOptions(collapsed = FALSE)) 
```


## Matrices de temps et itin√©raires

Le package `osrm` (@R-osrm) sert d‚Äôinterface entre R et le service de calcul d‚Äôitin√©raire [OSRM](http://project-osrm.org/) (Luxen et Vetter, 2011). Ce package permet de calculer des matrices de temps et de distances, des itin√©raires routiers, des isochrones. Le package utilise par d√©faut le serveur de d√©mo d‚ÄôOSRM. En cas d‚Äôutilisation intensive il est fortement recommand√© d‚Äô[utiliser sa propre instance d‚ÄôOSRM avec Docker](https://rcarto.github.io/posts/build_osrm_server/).

La fonction `osrmTable()` permet de calculer des matrices de distances ou de temps par la route. Nous effectuons cette op√©ration entre le centroide de chaque secteur et les cliniques / h√¥pitaux extraits plus haut avec `osmextract`. 

```{r}
# Choisir un gouvernorat
sel <- sect[sect$id_hasc_gouv == "TN.SS",]
sel <- sel[!is.na(sel$osm_id),]
sel <- sel[!duplicated(sel$osm_id),]

# Origines (centroides des secteurs)
ori <- st_centroid(sel)

# Consid√©rer les cliniques et h√¥pitaux dans un voisinage de 20 km autour de la d√©l√©gation
osm_pt <- st_transform(osm_pt, 2088) # Transformer en coordonn√©es planaires
sel <- st_transform(sel, 2088)
dest <- st_filter(osm_pt, st_buffer(sel, 20000), .predicate = st_intersects)
dest <- st_transform(dest, 4326)

# Calcul de temps de trajets avec OSRM (pas grosse requ√™te)
library(osrm)
df <- osrmTable(src = ori, dst = dest, measure = "duration")

# Extraire les temps de trajet
df <- data.frame(df$durations)

# Formater la table d'une mani√®re arrangeante
colnames(df) <- as.character(dest$osm_id)
row.names(df) <- as.character(ori$osm_id)
head(df)
```

On peut ensuite assez ais√©ment avec la fonction `apply()` extraire le temps de trajet minimal par secteur. 

```{r}
time <- apply(df, 1, min) 
time <- data.frame(time)
time$osm_id <- row.names(time)
head(time)
```

Nous finissons par une jointure attributaire avec la couche g√©ographique des secteurs, ce qui permet de r√©aliser une repr√©sentation cartographique des r√©sultats avec le package `mapsf` qui sera pr√©sent√© ult√©rieurement dans la formation. 

```{r}
#| code-fold: true
sel <- merge(sel, time, by = "osm_id", all.x = TRUE)
deleg <- st_transform(deleg, 2088)
dest <- st_transform(dest, 2088)

library(mapsf)
par(mfrow = c(1,1))
mf_init(sel)
mf_map(deleg, col = "lightgrey", 
       border = NA,
       add = TRUE)
mf_map(sel, 
       type = "choro",
       var = "time",
       nbreaks = 4,
       border = "white", 
       leg_title = "Minutes en voiture", 
       add = TRUE)
mf_map(deleg, col = NA, 
       border = "black",
       add = TRUE)
mf_map(dest, pch = 21, col = NA, bg = "red", add = TRUE)
mf_scale(size = 10)
mf_title("D√©l√©gation de Sousse : Temps de trajet vers l'h√¥pital ou la clinique la plus proche")
mf_credits(paste0("Source: ¬© OpenStreetMap et Contributeurs, 2024\n",
                  "NB/ Toute chose √©gale par rapport √† la compl√©tude d'OSM. Contribuez pour compl√©ter la carte le cas √©ch√©ant !"))
```


# A vous de jouer !

L'ensemble des donn√©es pr√©sent√©es dans ce tutoriel ont √©t√© rassembl√©es dans le dossier `data`. Vous √™tes invit√©s sur un espace de votre choix (Monde / Tunisie) √† :

- Importer un jeu de donn√©es tabulaire.
- Importer une couche g√©ographique vectorielle.
- Faire une jointure attributaire.
- Choisir une variable et r√©aliser un r√©sum√© statistique (`summary()`) et un graphique pr√©sentant la distribution des valeurs de la variable.
- Faire une carte avec la fonction `plot()`


### Session Info

```{r}
sessionInfo()
```